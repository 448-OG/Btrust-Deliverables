use pbkdf2::pbkdf2_hmac;
use rand_chacha::ChaCha20Rng;
use rand_core::{RngCore, SeedableRng};
use sha2::{Digest, Sha256, Sha512};
use std::{
    fs::File,
    io::{self, prelude::*},
    path::{Path, PathBuf},
};

fn main() {
    let mut insecure_generator = Bip39Generator::new("english.txt");

    let (insecure_mnemonic, insecure_seed) = insecure_generator.insecure_mnemonic::<16>().unwrap();

    let mut secure_generator = Bip39Generator::new("english.txt");
    let passphrase = "BitCoin_iZ_Awesome";

    let (secure_mnemonic, secure_seed) =
        secure_generator.secure_mnemonic::<16>(&passphrase).unwrap();

    let restored_insecure = Bip39Generator::recover_insecure(&insecure_mnemonic).unwrap();
    let restored_secure = Bip39Generator::recover_secure(&secure_mnemonic, passphrase).unwrap();

    assert_eq!(&insecure_seed, &restored_insecure);
    assert_eq!(&secure_seed, &restored_secure);
}

pub const ITERATION_COUNT: u32 = 2048;
pub const SALT_PREFIX: &str = "mnemonic";

#[derive(Debug, Default)]
pub struct Bip39Generator {
    mnemonic_index: Vec<u16>,
    appended: Vec<u8>,
    path: PathBuf,
}

impl Bip39Generator {
    pub fn new(path_to_wordlist: impl AsRef<Path>) -> Self {
        Self {
            path: path_to_wordlist.as_ref().to_path_buf(),
            ..Default::default()
        }
    }

    pub fn insecure_mnemonic<const N: usize>(&mut self) -> io::Result<(String, Vec<u8>)> {
        println!("Your Mnemonic is:");

        let mnemonic = self.mnemonic::<N>()?;
        let seed = Bip39Generator::seed(mnemonic.as_str(), Option::None)?;

        Ok((mnemonic, seed))
    }

    pub fn secure_mnemonic<const N: usize>(
        &mut self,
        passphrase: &str,
    ) -> io::Result<(String, Vec<u8>)> {
        println!("Your Mnemonic Generated by passphrase `{}` is:", passphrase);

        let mnemonic = self.mnemonic::<N>()?;
        let seed = Bip39Generator::seed(mnemonic.as_str(), Option::Some(passphrase))?;

        Ok((mnemonic, seed))
    }

    pub fn seed(mnemonic: &str, passphrase: Option<&str>) -> io::Result<Vec<u8>> {
        let salt = if let Some(passphrase_required) = passphrase {
            String::new() + SALT_PREFIX + passphrase_required
        } else {
            String::from(SALT_PREFIX)
        };

        let mut wallet_seed = [0u8; 512];
        pbkdf2_hmac::<Sha512>(
            mnemonic.as_bytes(),
            salt.as_bytes(),
            ITERATION_COUNT,
            &mut wallet_seed,
        );

        Ok(wallet_seed.to_vec())
    }

    pub fn mnemonic<const N: usize>(&mut self) -> io::Result<String> {
        let entropy = Entropy::<{ N }>::generate();

        self.generate_checksum::<N>(entropy.0);

        self.compute();

        let wordlist = self.load_wordlist()?;

        let mnemonic = self
            .mnemonic_index
            .iter()
            .enumerate()
            .map(|(index, line_number)| {
                let word = (&wordlist[*line_number as usize]).clone() + " ";
                let index = index + 1;

                let indexed = if index < 10 {
                    String::new() + " " + index.to_string().as_str()
                } else {
                    index.to_string()
                };

                println!("{}. {}", indexed, &word);

                word
            })
            .collect::<String>();

        Ok(mnemonic.trim().to_owned())
    }

    fn load_wordlist(&mut self) -> io::Result<Vec<String>> {
        let file = File::open(&self.path)?;
        let reader: io::BufReader<File> = io::BufReader::new(file);

        let mut wordlist = Vec::<String>::new();

        for line in reader.lines() {
            wordlist.push(line?);
        }

        Ok(wordlist)
    }

    fn generate_checksum<const N: usize>(&mut self, entropy: [u8; N]) -> &mut Self {
        let mut hasher = Sha256::new();
        hasher.update(entropy.as_slice());

        let entropy_hash = hasher.finalize();

        let bits_of_entropy = entropy.len() * 8;
        let bits_of_checksum = bits_of_entropy / 32;
        let significant = entropy_hash[0] >> bits_of_checksum;

        let mut appended = entropy.to_vec();
        appended.push(significant);

        self.appended = appended;

        self
    }

    fn compute(&mut self) -> &mut Self {
        let mut bits = vec![];
        for &byte in self.appended.iter() {
            for i in (0..8).rev() {
                bits.push((byte >> i) & 1u8 == 1);
            }
        }

        for chunk in bits.chunks(11) {
            if chunk.len() == 11 {
                let mut value: u16 = 0;
                for (i, &bit) in chunk.iter().enumerate() {
                    if bit {
                        value |= 1u16 << (10 - i);
                    }
                }
                self.mnemonic_index.push(value);
            }
        }

        self
    }

    pub fn recover_secure(mnemonic: &str, passphrase: &str) -> io::Result<Vec<u8>> {
        Bip39Generator::recover(mnemonic, Option::Some(passphrase))
    }

    pub fn recover_insecure(mnemonic: &str) -> io::Result<Vec<u8>> {
        Bip39Generator::recover(mnemonic, Option::None)
    }

    pub fn recover(mnemonic: &str, passphrase: Option<&str>) -> io::Result<Vec<u8>> {
        Bip39Generator::seed(mnemonic, passphrase)
    }
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Entropy<const N: usize>([u8; N]);

impl<const N: usize> Entropy<N> {
    pub fn generate() -> Self {
        let mut rng = ChaCha20Rng::from_entropy();
        let mut buffer = [0u8; N];
        rng.fill_bytes(&mut buffer);

        Self(buffer)
    }
}
